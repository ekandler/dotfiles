/*************************************************************************
 Source file of generic stream device driver for windows ce 6.0

*************************************************************************/

#include "stdafx.h"
#include <windows.h>						// for all that windows stuff
#include <commctrl.h>
#include "eos_driver.h"						// local program includes
#include "gpio.h"
#include "mapreg.h"
#include "ledswitch.h"
#include "eos_defines.h"



// globals
HINSTANCE hInst;							// dll instance handle

//driver instance structure
/*
typedef struct{
	DWORD dwSize;
	int nNumOpens;
	GPIOREG * pGpioRegs;
}DRVCONTEXT, *PDRVCONTEXT;
*/


static HANDLE hISR;
static DWORD dwSysIntr;
static HANDLE eventHandle;
static LPVOID statMapped;
static HANDLE ThreadHdl;

DWORD WINAPI ExampleThread(LPVOID pParam) {

	PDRVCONTEXT pDrv = (PDRVCONTEXT) pParam;
	GPIOREG * g_pGPIORegs = pDrv->pGpioRegs;
	RETAILMSG(1, (TEXT("Thread started \r\n")));
    while( 1 )
    {
		WaitForSingleObject(pDrv->hEvent, INFINITE);
		g_pGPIORegs->gpsr1 = (1 << 4); // set GPIO36 -> LED2 on
		//RETAILMSG(1, (TEXT("Switching LED \r\n")));
		
		
		g_pGPIORegs->gpcr1 = (1 << 4); // reset GPIO36 -> LED2 off
    }
    return 0;             
}


void LoadISRDll(PDRVCONTEXT pDrv) {
	DWORD dwGpio = 15;
	//DWORD dwGpio = 25;
	DWORD dwIrq;
	DWORD dwEdge = GPIO_EDGE_RISING;
	DWORD ThreadID;

	ISR_INFO isr_info;
	RETAILMSG(RETAIL_ON, (TEXT("Loading ISRDll \r\n")));

	if (!KernelIoControl(IOCTL_HAL_GPIO2IRQ, &dwGpio, sizeof(DWORD), &dwIrq, sizeof(DWORD), NULL)) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in KernelIoControl (get IRQ number) \r\n")));
	}

	if (!KernelIoControl(IOCTL_HAL_IRQEDGE, &dwIrq, sizeof(BYTE), &dwEdge, sizeof(BYTE), NULL)) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in KernelIoControl (set edge) \r\n")));
	}

	if (!KernelIoControl(IOCTL_HAL_REQUEST_SYSINTR, &dwIrq, sizeof(DWORD), &dwSysIntr, sizeof(DWORD), NULL)) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in KernelIoControl (get SYSINTR) \r\n")));
	}

	// CreateEvent for IST
	eventHandle = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (eventHandle == NULL) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in CreateEvent \r\n")));
	}

	if (!InterruptInitialize(dwSysIntr, eventHandle, NULL, 0)) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in InterruptInitialize \r\n")));
	}

	hISR = LoadIntChainHandler(TEXT("\\Program Files\\eos_driver\\ISRDll.dll"), TEXT("ISRHandler"), (BYTE)dwIrq);
	if (hISR == NULL) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in LoadIntChainHandler \r\n")));
	}

	statMapped = CreateStaticMapping(GPIO_BASE >> 8, PAGE_SIZE);
	if (statMapped == NULL) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in CreateStaticMapping \r\n")));
	}


	
	isr_info.SysIntr = dwSysIntr;
	isr_info.pGPIORegs = (GPIOREG*)statMapped;
	if (!KernelLibIoControl(hISR, IOCTL_ISR_INFO, &isr_info, sizeof(isr_info), NULL, 0, NULL)) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in KernelLibIoControl \r\n")));
	}


	pDrv->hEvent = eventHandle;
	ThreadHdl = CreateThread(NULL, 0, ExampleThread, (LPVOID) pDrv,0,&ThreadID);
	if (ThreadHdl == NULL) {
		RETAILMSG(RETAIL_ON, (TEXT("Error in CreateThread \r\n")));
	}

	// Thread prio
	if (!CeSetThreadPriority(ThreadHdl, 10)) {
		RETAILMSG(RETAIL_ON, (TEXT("Setting thread prio failed \r\n")));
	}


	
}

void UnloadISRDll() {
	// TODO: Free thread here
	TerminateThread(ThreadHdl, 0);

	FreeIntChainHandler(hISR);

	InterruptDisable(dwSysIntr);

	KernelIoControl(IOCTL_HAL_RELEASE_SYSINTR, &dwSysIntr, sizeof(DWORD), NULL, 0, NULL);

	CloseHandle(eventHandle);

	DeleteStaticMapping(statMapped, sizeof(GPIOREG));
}

//=======================================================================
//DLLMain - DLL initialization entry point
//
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
	hInst = (HINSTANCE)hModule;

	switch(ul_reason_for_call){
		case DLL_PROCESS_ATTACH:
			RETAILMSG(RETAIL_ON, (TEXT("DLL_PROCESS_ATTACH \r\n")));
			// improve performance by passing on thread attach calls
			DisableThreadLibraryCalls(hInst);

			break;

		case DLL_PROCESS_DETACH:
			RETAILMSG(RETAIL_ON, (TEXT("DLL_PROCESS_DETACH\r\n")));
			break;
	}
    return TRUE;
}

//=======================================================================
// EOS_Init - Driver initialization function
//
DWORD EOS_Init(LPCSTR pContext, DWORD dwBusContext){
	PDRVCONTEXT pDrv;
	
	RETAILMSG(RETAIL_ON, (TEXT("EOS_Init++ dwContext: %x\r\n"), pContext));

	// Allocate a driver instance structure - required if we want to manage
	// more instances
	pDrv = (PDRVCONTEXT)LocalAlloc(LPTR, sizeof(DRVCONTEXT));

	if(pDrv){
		// initialize structure
		memset((PBYTE) pDrv, 0, sizeof(DRVCONTEXT));
		pDrv->dwSize = sizeof(DRVCONTEXT);

		// read registry to determine the size of the disk
		// GetConfigData((DWORD)pContext);
	}else{
		RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Init failure. Out of memory\r\n"), pContext));
	}

	pDrv->pGpioRegs = (GPIOREG *) MapRegister(GPIO_BASE);
	if (pDrv->pGpioRegs == NULL) {
		return -1;
	}


	initSwitches(pDrv->pGpioRegs);
	initPushButtons(pDrv->pGpioRegs);
	initLeds(pDrv->pGpioRegs);

	
	LoadISRDll(pDrv);
	


	
	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Init-- pDrv: %x\r\n"), pDrv));

	return (DWORD)pDrv;
}




//=======================================================================
// EOS_Open - Called when driver opened
// Use dwAccess and dwShare flags to manage access rights
//
DWORD EOS_Open(DWORD dwContext, DWORD dwAccess, DWORD dwShare){
	PDRVCONTEXT pDrv = (PDRVCONTEXT)dwContext;

	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Open++ dwContext: %x\r\n"), dwContext));

	// Verify that the context handle is valid
	if(pDrv && (pDrv->dwSize != sizeof(DRVCONTEXT))){
		return 0;
	}
	// Count the number of opens
	InterlockedIncrement((long *)&pDrv->nNumOpens);

	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Open-- dwContext: %x\r\n"), dwContext));


	return (DWORD)pDrv;
}





BOOL EOS_Deinit(DWORD dwContext) {
	PDRVCONTEXT pDrv = (PDRVCONTEXT)dwContext;
	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Deinit++ dwContext: %x\r\n"), dwContext));

	UnMapRegister((void*) pDrv->pGpioRegs);
	
	UnloadISRDll();

	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Deinit-- dwContext: %x\r\n"), dwContext));
	return true;
}


BOOL EOS_Close(DWORD dwOpen) {
	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Close++ dwOpen: %x\r\n"), dwOpen));
	
	
	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Close-- dwOpen: %x\r\n"), dwOpen));
	return true;
}

DWORD EOS_Read(DWORD dwOpen, LPVOID pBuffer, DWORD dwCount) {
	PDRVCONTEXT pDrv = (PDRVCONTEXT)dwOpen;

	//RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Read++ dwOpen: %x\r\n"), dwOpen));

	char switches = readSwitches(pDrv->pGpioRegs);
	char buttons = readPushButtons(pDrv->pGpioRegs);
	char retval = (buttons<<4) | switches;
	//RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Read val: %x\r\n"), retval));

	char * out = (char*)pBuffer;

	*out = retval;


	//RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Read-- dwOpen: %x\r\n"), dwOpen));
	return 1;
}

DWORD EOS_Write(DWORD dwOpen, LPVOID pBuffer, DWORD dwCount) {
	PDRVCONTEXT pDrv = (PDRVCONTEXT)dwOpen;
	//RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Write++ dwOpen: %x\r\n"), dwOpen));

	char value = ((char*)pBuffer)[0];
	//RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Write val: %x\r\n"), value));
	setLeds(pDrv->pGpioRegs, value);



	//RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Write-- dwOpen: %x\r\n"), dwOpen));
	return dwCount;
}


DWORD EOS_Seek(DWORD dwOpen, long lDelta, WORD wType) {
	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Seek++ dwOpen: %x\r\n"), dwOpen));


	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_Seek-- dwOpen: %x\r\n"), dwOpen));

	return 0;
}

DWORD EOS_IOControl(DWORD dwOpen, DWORD dwCode, PBYTE pIn, DWORD dwIn, 
					PBYTE pOut, DWORD dwOut, DWORD *pdwBytesWritten) {
	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_IOControl++ dwOpen: %x\r\n"), dwOpen));


	RETAILMSG(RETAIL_ON, (DTAG TEXT("EOS_IOControl-- dwOpen: %x\r\n"), dwOpen));

	return 0;
}